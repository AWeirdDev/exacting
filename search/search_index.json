{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Exacting","text":"<p>(adj.) making great demands on one's skill, attention, or other resources.</p> <p><code>exacting</code> is a picky dataclass runtime utility collection, making sure all type annotations are followed.</p> <p>Essentially... THE go-to option for dataclasses. heh.</p> <p>\ud83d\udd11 Key features:</p> <ul> <li>100% static typing. Because I hate nothing too.</li> <li>Generally faster than <code>pydantic</code>!</li> </ul> <p></p> <p></p> <p>\ud83d\udecd\ufe0f Get <code>exacting</code>:</p> pipuvgit <pre><code>pip install -U exacting\n</code></pre> <pre><code>uv pip install -U exacting\n</code></pre> <pre><code>git clone https://github.com/AWeirdDev/exacting\n</code></pre> <p>\ud83d\udd25 Define some model:</p> Python 3.10+Python &lt;= 3.9 <pre><code>from exacting import Exact\n\nclass Actor(Exact):\n    name: str\n    portrays: str\n\nclass Show(Exact):\n    name: str\n    description: str | None\n    actors: list[Actor]\n</code></pre> <pre><code>from typing import List, Optional\nfrom exacting import Exact\n\nclass Actor(Exact):\n    name: str\n    portrays: str\n\nclass Show(Exact):\n    name: str\n    description: Optional[str]\n    actors: List[Actor]\n</code></pre> <p>\ud83d\udce6 Build 'em:</p> <pre><code># (1) \u2705 OK, exacting is happi\nShow(\n    name=\"Severance\",\n    description=\"great show\",\n    actors=[\n        Actor(name=\"Adam Scott\", portrays=\"Mark S.\"),\n        Actor(name=\"Britt Lower\", portrays=\"Helly R.\"),\n    ]\n)\n\n# (2) \u274c Nuh-uh, exacting is angri\nShow(\n    name=123,\n    description=False,\n    actors=[\n        \"Walter White\",\n        \"Jesse Pinkman\"\n    ]\n)\n</code></pre> ValidationError: During validation of\u2026 <pre><code>ValidationError:\nDuring validation of dataclass Show at field 'name', got:\n  \u2022 Expected type &lt;class 'str'&gt;, got &lt;class 'int'&gt;\n</code></pre> <p>Normally, when you use the parameters passed in example (2) above, the Python <code>dataclasses</code> library might as well just go with it, because they only put the additional static typing to the model, but not at runtime. Exacting makes sure that at both times, types are all enforced. It even gives you a detailed error message on where this occurs! (In a cool way)</p> <p>It's worth noting that error generations are lazy, which means once Exacting finds out about a problem about a dataclass, it raises a <code>ValidationError</code>. This saves a lot of computation time if you have a larger model.</p>"},{"location":"dumping/","title":"Dumping","text":"<p>Dump the model to a data format. Supports nested items.</p>"},{"location":"dumping/#json","title":"JSON","text":"<p>Everyone's favorite data type.</p> <pre><code>from exacting import Exact\n\nclass Money(Exact):\n    swag: bool\n\nmoney = Money(swag=True)\n\njson = money.exact_as_json()\nprint(json)  # {\"swag\": true}\n\ndata = Money.exact_from_json(json)\nprint(data)  # Money(swag=True)\n</code></pre> <p>Side note, you can actually load from JSON with comments (jsonc). Just disable strict mode via <code>strict=False</code>.</p> <pre><code>json = \"\"\"{\n    \"swag\": /* false */ true, // yeah, trailing commas\n}\"\"\"\n\ndata = Money.exact_from_json(json, strict=False)\nprint(data)  # Money(swag=True)\n</code></pre>"},{"location":"dumping/#bytes","title":"Bytes","text":"<p>Exacting uses rkyv for serialization/deserialization.</p> <p>Lazy developer warning</p> <p>This thingy is experimental. It's not yet ready for production, y'know.</p> <pre><code>from exacting import Exact\n\nclass Place(Exact):\n    name: str\n\nplace = Place(name=\"Freddy Fazbear's Pizza\")\narchive = place.exact_as_bytes()\nprint(archive)  # b\"\\x00\\x00\\x00\\x00name\\xff...\"\n\ndata = Place.exact_from_bytes(archive)\nprint(data)  # Place(name=\"Freddy Fazbear's Pizza\")\n</code></pre>"},{"location":"fields/","title":"Fields","text":"<p>Fields in <code>exacting</code> are rather pretty straightforward, just as what you'd expect from <code>dataclasses</code>.</p> <pre><code>from exacting import Exact, field\n\nclass StoreItem(Exact):\n    name: str = field()\n    price: int = field()\n</code></pre>"},{"location":"fields/#min-max","title":"Min, max","text":"<p>You can check for the minimum/maximum length or value by passing the <code>minv</code> or <code>maxv</code> parameter.</p> <pre><code>from exacting import Exact, field\n\nclass Sequence(Exact):\n    id: str = field(minv=2)  # checks for len()\n    some: int = field(maxv=4)  # checks for value\n    data: list[int] = field(minv=4, maxv=4)  # len() must be 4\n\n\n# \u2705 OK!\nSequence(\n    id=\"hello\",\n    some=4,\n    data=[1, 2, 3, 4]\n)\n</code></pre>"},{"location":"fields/#regex","title":"Regex","text":"<p><code>exacting</code> also has a built-in Regex matching field utility.</p> <pre><code>from exacting import Exact, field\n\nclass Hamburger(Exact):\n    name: str = field(regex=\"^[A-Z]+$\")\n\n# \u2705 GOOD. Emphasized enough!\nHamburger(name=\"WHOPPER\")\n\n# \u274c ERROR. Can you be louder?\nHamburger(name=\"bigmac\")\n</code></pre> <p>Note that the <code>regex</code> parameter won't work (skipped) if used on field types that aren't <code>str</code>.</p>"},{"location":"fields/#aliases","title":"Aliases","text":"<p>Aliases are only used when serializing/deserializing.</p> <p>Warning</p> <p>We're still working on it... stay tuned, I guess.</p>"},{"location":"internals/result/","title":"Result","text":"<p>The <code>Result</code> class indicates the success/failure of validation.</p> <pre><code>from exacting import Result\n\n# Success\nResult.Ok(\"some value\")\n\n# Error\nResult.Err(\n    \"You bad\",\n    \"literally\"\n)\n</code></pre>"},{"location":"internals/result/#is-ok","title":"Is OK?","text":"<p>This checks if the validation result is OK.</p> <pre><code>if some_result.is_ok():\n    ... # good!\nelse:\n    ... # bad!\n</code></pre>"},{"location":"internals/result/#raising","title":"Raising","text":"<p><code>Result</code> can help you raise a <code>ValidationError</code> if errors are present.</p> <pre><code>some_result.raise_for_err()\n</code></pre>"},{"location":"internals/result/#unwrapping","title":"Unwrapping","text":"<p>You can get the data that got through the validation by unwrapping, or the error messages.</p> <pre><code>ok = Result.Ok(-123)\nprint(ok.unwrap())  # -123\n\nerr = Result.Err(\"be be nos\")\nprint(err.unwrap_err())  # deque(['be be nos'])\n</code></pre>"},{"location":"internals/result/#trace","title":"Trace","text":"<p>You can trace errors down using the <code>trace()</code> function, making previous errors appear indented.</p> <pre><code>base_err = Result.Err(\"Gustavo Fring\")\n\n(\n    base_err\n        .trace(\"Woah, there's a gustavo down here\")\n        .trace(\"Breaking bad!\")\n        .raise_for_err()\n)\n</code></pre> ValidationError: Breaking bad! <pre><code>ValidationError: \nBreaking bad!\n  \u2022 Woah, there's a gustavo down here\n    \u2022 Gustavo Fring\n</code></pre>"},{"location":"internals/result/#trace-below","title":"Trace below","text":"<p>Make other errors appear indented below your message.</p> <pre><code>error1 = Result.Err(\"ooga\", \"booga\")\nerror2 = Result.trace_below(\n    \"Check these out:\",\n    *error1.unwrap_err()\n)\n\nerror2.raise_for_err()\n</code></pre> ValidationError: Check these out: <pre><code>ValidationError: \nCheck these out:\n  \u2022 ooga\n  \u2022 booga\n</code></pre>"},{"location":"internals/unsafe/","title":"Unsafe","text":"<p>If you take a closer look at a model inherited from the <code>Exact</code> model, there's a <code>__unsafe_init__()</code> function which allows you to skip all type checks.</p> <p>However, if directly called, you'd get an error:</p> <pre><code>from exacting import Exact\n\nclass Person(Exact):\n    name: str\n\nPerson.__unsafe_init__(name=\"Walter\")\n</code></pre> RuntimeError: Scope is not in unsafe()\u2026 <pre><code>RuntimeError: Scope is not in unsafe(), canceled operation\n</code></pre>"},{"location":"validators/annotated/","title":"Annotated","text":"<p>Annotated types allow you to annotate any value onto the type field.</p> <pre><code>from typing import Annotated\n\n#         type, metadata.......\nAnnotated[str,  \"any data\", 123]\n</code></pre> <p><code>exacting</code> only checks for the type, not the metadata.</p> <p>For future development of <code>exacting</code>, it might be used as a doc field.</p>"},{"location":"validators/annotated/#validator","title":"Validator","text":"<p>The <code>AnnotatedV</code> (\"Annotated\" validator) focuses on the target validator provided in the first parameter, the metadata is not related to the validation and is only stored for later use.</p> <pre><code>from exacting import AnnotatedV, IntV\n\nva = AnnotatedV(IntV(), [\"some\", \"metadata\"])\n\nva.metadata  # list[Any]\nva.target  # int (validator)\n\nva.validate(123)  # Ok!\nva.validate(1.2)  # ERROR\n</code></pre>"},{"location":"validators/any/","title":"Any","text":"<p>The <code>Any</code> type allows any type to be on the surface, which is generally not a good practice in production.</p> <pre><code>from typing import Any\n\nAny\n</code></pre>"},{"location":"validators/any/#validator","title":"Validator","text":"<p>The <code>AnyV</code> (\"Any\" validator) grants every type.</p> <pre><code>from exacting import AnyV\n\nva = AnyV()\nva.validate(123)  # Ok!\nva.validate(\"W\")  # Ok!\n</code></pre>"},{"location":"validators/custom/","title":"Custom","text":"<p>Under construction</p> <p>The full API documentation is not yet complete :(</p> <p>Yup. Starting from <code>v0.2.0</code>, the custom validator API gets a little more easy on your eyes.</p> <p>Let's say we want to make a custom type that checks if the integers of a list are all divisible by 5.</p> <pre><code>from exacting import Validator, Result, ListV, IntV\n\nlist_of_int = ListV(IntV())\n\nclass CoolListV(Validator):\n    \"\"\"My cool list validator :)\"\"\"\n\n    def validate(self, value, **options) -&gt; Result:\n        # It must be a list of integers!\n        res: Result = list_of_int.validate(value)\n        if not res.is_ok():\n            # not a list\n            return res\n\n        the_list = res.unwrap()\n        for item in the_list:\n            if item % 5 != 0:\n                return Result.Err(\"Not divisible by 5\")\n\n        return Result.Ok(the_list)\n</code></pre> <p>Then, try it out:</p> <pre><code>va = CoolListV()\nresult = va.validate([10, 20, 30])\nresult.raise_for_err()  # no error!\n\nassert result.unwrap() == [10, 20, 30]\n</code></pre> <p>Or use it on an <code>Exact</code> model:</p> <pre><code>from typing import Any\nfrom exacting import Exact, field\n\nclass Numbers(Exact):\n    # for demo, we'll use Any for now to show \n    # the validator's work\n    array: Any = field(validators=[CoolListV()])\n\nNumbers(array=[100])  # Ok!\nNumbers(array=[123])  # ERROR\n</code></pre>"},{"location":"validators/literal/","title":"Literal","text":"<p>Literal types tell <code>exacting</code> to check for value equality instead of types.</p> <pre><code>from typing import Literal\n\nLiteral[\"Hello\", b\"beep\", 123, True]\n</code></pre> <p>There can be multiple <code>Literal</code> items.</p> <p>Literal types perform exactly as intended in <code>exacting</code>.</p>"},{"location":"validators/literal/#validator","title":"Validator","text":"<p>The <code>LiteralV</code> (\"Literal\" validator) checks the equailty of the target values (the \"OK\" ones) and the provided value.</p> <p>This validator loops through <code>self.values</code> and returns immediately once a match is found.</p> <pre><code>from exacting import LiteralV\n\nva = LiteralV([\"A\", 1, True])\n\nva.values # list[Any]\n\nva.validate(\"A\")  # Ok!\nva.validate(1)  # Ok!\nva.validate(True)  # Ok!\nva.validate(\"B\")  # ERROR\n</code></pre>"},{"location":"validators/native/","title":"Native types","text":"<p>Most native types are instantly available! These are all the available types:</p> <pre><code>str\nint\nfloat\nbool\nbytes\nlist[...]\ndict[..., ...]\n</code></pre> <p>You probably noticed that <code>tuple</code> or <code>set</code> isn't available. Yes, currently.</p>"},{"location":"validators/native/#validators","title":"Validators","text":"<p>For non-container-like types:</p> <pre><code>from exacting import (\n    StrV, \n    IntV, \n    FloatV, \n    BoolV, \n    BytesV\n)\n</code></pre> <p>For container-like types:</p> <pre><code>from exacting import ListV, DictV\n\nlva = ListV(StrV())  # list[str] (validator)\ndva = ListV(StrV(), StrV())  # dict[str, str] (validator)\n</code></pre>"},{"location":"validators/union/","title":"Union","text":"<p>The union type allows you to have multiple choices of types.</p> Python 3.10+Python &lt;= 3.9 <pre><code>A | B | C\n</code></pre> <pre><code>from typing import Union\n\nUnion[A, B, C]\n</code></pre> <p>Union types perform exactly as intended in <code>exacting</code>.</p>"},{"location":"validators/union/#validator","title":"Validator","text":"<p>You can do more than two items for Union by hand, or use an exposed function called <code>union()</code> to speed up the process.</p> <pre><code>from exacting import UnionV, union\n\n# by hand\nva = UnionV(StrV(), UnionV(BoolV(), IntV()))\n\n# union()\nva = union(StrV(), BoolV(), IntV())\n\nva.a  # str (validator)\nva.b  # bool | int (validator)\n\nva.b.a  # bool (validator)\nva.b.b  # int (validator)\n</code></pre>"}]}